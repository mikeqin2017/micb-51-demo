C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/08/2018 09:45:14 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\shuwen.
                    -ou\SimplicityStudio\v4_workspace\MICB-51\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOAT
                    -FUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\shuwen.ou\SimplicityStudio\v4_wo
                    -rkspace\MICB-51\inc;C:\Users\shuwen.ou\SimplicityStudio\v4_workspace\MICB-51\inc\config;C:/SiliconLabs/SimplicityStudio/
                    -v4/developer/sdks/8051/v4.1.1//kits/common/bsp;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//kits/EFM8U
                    -B2_SLSTK2001A/config;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8UB2/peripheral_driver/inc
                    -;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/shared/si8051base;C:/SiliconLabs/SimplicityStudio
                    -/v4/developer/sdks/8051/v4.1.1//Device/EFM8UB2/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//kits/c
                    -ommon/drivers/efm8_retargetserial) PRINT(.\src\Interrupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupt
                    -s.OBJ)

line level    source

   1          #include <SI_EFM8UB2_Register_Enums.h>
   2          
   3          //-----------------------------------------------------------------------------
   4          // Global CONSTANTS
   5          //-----------------------------------------------------------------------------
   6          
   7          // System clock frequency in Hz
   8          #define  SYSCLK         12000000
   9          
  10          #define  SMB_FREQUENCY  30000          // Target SCL clock rate
  11          // This example supports between 10kHz
  12          // and 100kHz
  13          
  14          #define  WRITE          0x00           // SMBus WRITE command
  15          #define  READ           0x01           // SMBus READ command
  16          
  17          // Device addresses (7 bits, lsb is a don't care)
  18          #define  EEPROM_ADDR    0xA0           // Device address for slave target
  19          // Note: This address is specified
  20          // in the Microchip 24LC02B
  21          // datasheet.
  22          // SMBus Buffer Size
  23          #define  SMB_BUFF_SIZE  0x08           // Defines the maximum number of bytes
  24          // that can be sent or received in a
  25          // single transfer
  26          
  27          // Status vector - top 4 bits only
  28          #define  SMB_MTSTA      0xE0           // (MT) start transmitted
  29          #define  SMB_MTDB       0xC0           // (MT) data byte transmitted
  30          #define  SMB_MRDB       0x80           // (MR) data byte received
  31          // End status vector definition
  32          
  33          //-----------------------------------------------------------------------------
  34          // Global VARIABLES
  35          //-----------------------------------------------------------------------------
  36          extern uint8_t* pSMB_DATA_IN;          // Global pointer for SMBus data
  37          // All receive data is written here
  38          
  39          //extern uint8_t SMB_SINGLEBYTE_OUT;     // Global holder for single byte writes.
  40          
  41          extern uint8_t* pSMB_DATA_OUT;         // Global pointer for SMBus data.
  42          // All transmit data is read from here
  43          
  44          extern uint8_t SMB_DATA_LEN;           // Global holder for number of bytes
  45          // to send or receive in the current
  46          // SMBus transfer.
  47          
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/08/2018 09:45:14 PAGE 2   

  48          extern uint8_t WORD_ADDR;              // Global holder for the EEPROM word
  49          // address that will be accessed in
  50          // the next transfer
  51          
  52          extern uint8_t TARGET;                 // Target SMBus slave address
  53          
  54          extern bool SMB_BUSY;                   // Software flag to indicate when the
  55          // EEPROM_ByteRead() or
  56          // EEPROM_ByteWrite()
  57          // functions have claimed the SMBus
  58          
  59          extern bool SMB_RW;                     // Software flag to indicate the
  60          // direction of the current transfer
  61          
  62          extern bool SMB_SENDWORDADDR;           // When set, this flag causes the ISR
  63          // to send the 8-bit <WORD_ADDR>
  64          // after sending the slave address.
  65          
  66          extern bool SMB_RANDOMREAD;             // When set, this flag causes the ISR
  67          // to send a START signal after sending
  68          // the word address.
  69          // For the 24LC02B EEPROM, a random read
  70          // (a read from a particular address in
  71          // memory) starts as a write then
  72          // changes to a read after the repeated
  73          // start is sent. The ISR handles this
  74          // switchover if the <SMB_RANDOMREAD>
  75          // bit is set.
  76          
  77          extern bool SMB_ACKPOLL;                // When set, this flag causes the ISR
  78          // to send a repeated START until the
  79          // slave has acknowledged its address
  80          
  81          //-----------------------------------------------------------------------------
  82          // SMBus Interrupt Service Routine (ISR)
  83          //-----------------------------------------------------------------------------
  84          //
  85          // SMBus ISR state machine
  86          // - Master only implementation - no slave or arbitration states defined
  87          // - All incoming data is written starting at the global pointer <pSMB_DATA_IN>
  88          // - All outgoing data is read from the global pointer <pSMB_DATA_OUT>
  89          //
  90          SI_INTERRUPT(SMBUS0_ISR, SMBUS0_IRQn)
  91          {
  92   1              bool FAIL = 0;                       // Used by the ISR to flag failed
  93   1                                                                                       // transfers
  94   1      
  95   1              static char i;// Used by the ISR to count the
  96   1                                        // number of data bytes sent or
  97   1                                        // received
  98   1      
  99   1              static bool SEND_START = 0;// Send a start
 100   1      
 101   1              switch (SMB0CN0 & 0xF0)// Status vector
 102   1              {
 103   2                      // Master Transmitter/Receiver: START condition transmitted.
 104   2                      case SMB_MTSTA:
 105   2                      SMB0DAT = TARGET;// Load address of the target slave
 106   2                      SMB0DAT &= 0xFE;// Clear the LSB of the address for the
 107   2                                                      // R/W bit
 108   2                      SMB0DAT |= SMB_RW;// Load R/W bit
 109   2                      SMB0CN0_STA = 0;// Manually clear START bit
 110   2                      i = 0;// Reset data byte counter
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/08/2018 09:45:14 PAGE 3   

 111   2                      break;
 112   2      
 113   2                      // Master Transmitter: Data byte (or Slave Address) transmitted
 114   2                      case SMB_MTDB:
 115   2                      if (SMB0CN0_ACK)// Slave Address or Data Byte
 116   2                      {                             // Acknowledged?
 117   3                              if (SEND_START)
 118   3                              {
 119   4                                      SMB0CN0_STA = 1;
 120   4                                      SEND_START = 0;
 121   4                                      break;
 122   4                              }
 123   3                              if(SMB_SENDWORDADDR)       // Are we sending the word address?
 124   3                              {
 125   4                                      SMB_SENDWORDADDR = 0;   // Clear flag
 126   4                                      SMB0DAT = WORD_ADDR;// Send word address
 127   4      
 128   4                                      if (SMB_RANDOMREAD)
 129   4                                      {
 130   5                                              SEND_START = 1; // Send a START after the next SMB0CN0_ACK cycle
 131   5                                              SMB_RW = READ;
 132   5                                      }
 133   4      
 134   4                                      break;
 135   4                              }
 136   3      
 137   3                              if (SMB_RW==WRITE)         // Is this transfer a WRITE?
 138   3                              {
 139   4      
 140   4                                      if (i < SMB_DATA_LEN)   // Is there data to send?
 141   4                                      {
 142   5                                              // send data byte
 143   5                                              SMB0DAT = *pSMB_DATA_OUT;
 144   5      
 145   5                                              // increment data out pointer
 146   5                                              pSMB_DATA_OUT++;
 147   5      
 148   5                                              // increment number of bytes sent
 149   5                                              i++;
 150   5                                      }
 151   4                                      else
 152   4                                      {
 153   5                                              SMB0CN0_STO = 1;     // Set SMB0CN0_STO to terminte transfer
 154   5                                              SMB_BUSY = 0;// Clear software busy flag
 155   5                                      }
 156   4                              }
 157   3                              else {}                    // If this transfer is a READ,
 158   3                                                                                 // then take no action. Slave
 159   3                                                                                 // address was transmitted. A
 160   3                                                                                 // separate 'case' is defined
 161   3                                                                                 // for data byte recieved.
 162   3                      }
 163   2                      else                          // If slave NACK,
 164   2                      {
 165   3                              if(SMB_ACKPOLL)
 166   3                              {
 167   4                                      SMB0CN0_STA = 1;                // Restart transfer
 168   4                              }
 169   3                              else
 170   3                              {
 171   4                                      FAIL = 1;               // Indicate failed transfer
 172   4                              }                          // and handle at end of ISR
 173   3                      }
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/08/2018 09:45:14 PAGE 4   

 174   2                      break;
 175   2      
 176   2                      // Master Receiver: byte received
 177   2                      case SMB_MRDB:
 178   2                      if ( i < SMB_DATA_LEN )// Is there any data remaining?
 179   2                      {
 180   3                              *pSMB_DATA_IN = SMB0DAT;   // Store received byte
 181   3                              pSMB_DATA_IN++;// Increment data in pointer
 182   3                              i++;// Increment number of bytes received
 183   3                              SMB0CN0_ACK = 1;// Set SMB0CN0_ACK bit (may be cleared later
 184   3                              // in the code)
 185   3      
 186   3                      }
 187   2      
 188   2                      if (i == SMB_DATA_LEN)        // This is the last byte
 189   2                      {
 190   3                              SMB_BUSY = 0;              // Free SMBus interface
 191   3                              SMB0CN0_ACK = 0;// Send NACK to indicate last byte
 192   3                              // of this transfer
 193   3                              SMB0CN0_STO = 1;// Send STOP to terminate transfer
 194   3                      }
 195   2      
 196   2                      break;
 197   2      
 198   2                      default:
 199   2                      FAIL = 1;                     // Indicate failed transfer
 200   2                                                                                // and handle at end of ISR
 201   2                      break;
 202   2              }
 203   1      
 204   1              if (FAIL)                           // If the transfer failed,
 205   1              {
 206   2                      SMB0CF &= ~0x80;                 // Reset communication
 207   2                      SMB0CF |= 0x80;
 208   2                      SMB0CN0_STA = 0;
 209   2                      SMB0CN0_STO = 0;
 210   2                      SMB0CN0_ACK = 0;
 211   2      
 212   2                      SMB_BUSY = 0;// Free SMBus
 213   2      
 214   2                      FAIL = 0;
 215   2              }
 216   1      
 217   1              SMB0CN0_SI = 0;                             // Clear interrupt flag
 218   1      }
 219          
 220          //-----------------------------------------------------------------------------
 221          // Timer3 Interrupt Service Routine (ISR)
 222          //-----------------------------------------------------------------------------
 223          //
 224          // A Timer3 interrupt indicates an SMBus SCL low timeout.
 225          // The SMBus is disabled and re-enabled if a timeout occurs.
 226          //
 227          SI_INTERRUPT(TIMER3_ISR, TIMER3_IRQn)
 228          {
 229   1              SMB0CF &= ~0x80;                    // Disable SMBus
 230   1              SMB0CF |= 0x80;// Re-enable SMBus
 231   1              TMR3CN0 &= ~0x80;// Clear Timer3 interrupt-pending flag
 232   1              SMB_BUSY = 0;// Free bus
 233   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/08/2018 09:45:14 PAGE 5   

   CODE SIZE        =    283    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
