C51 COMPILER V9.53.0.0   MAIN                                                              01/08/2018 14:24:09 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\src\main.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\shuwen.
                    -ou\SimplicityStudio\v4_workspace\MICB-51\src\main.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(
                    -3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\shuwen.ou\SimplicityStudio\v4_workspac
                    -e\MICB-51\inc;C:\Users\shuwen.ou\SimplicityStudio\v4_workspace\MICB-51\inc\config;C:/SiliconLabs/SimplicityStudio/v4/dev
                    -eloper/sdks/8051/v4.1.1//kits/common/bsp;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//kits/EFM8UB2_SLS
                    -TK2001A/config;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8UB2/peripheral_driver/inc;C:/Si
                    -liconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/de
                    -veloper/sdks/8051/v4.1.1//Device/EFM8UB2/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//kits/common/
                    -drivers/efm8_retargetserial) PRINT(.\src\main.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\main.OBJ)

line level    source

   1          
   2          // Resources:
   3          //   SYSCLK - 48 MHz HFOSC / 4
   4          //   UART0  - 115200 baud, 8-N-1
   5          //   Timer1 - UART0 clock source
   6          //   P0.0   - Board Controller enable
   7          //   P0.4   - UART0 TX
   8          //   P0.5   - UART0 RX
   9          
  10          #include "bsp.h"
  11          #include "uart_0.h"
  12          #include "InitDevice.h"
  13          #include "retargetserial.h"
  14          #include "uart_1.h"
  15          #include "spi_0.h"
  16          
  17          //-----------------------------------------------------------------------------
  18          // Global Constants
  19          //-----------------------------------------------------------------------------
  20          #define EN 1
  21          #define DISEN 0     //SPI CS effective signal define
  22          #define BUFFER_LENGTH   5
  23          #define SYSCLK                24500000 // Internal oscillator frequency in Hz
  24          
  25          #define SPI_CLOCK               250000 // Maximum SPI clock
  26                                                 // The SPI clock is a maximum of 1 MHz
  27                                                 // when this example is used with
  28                                                 // the SPI0_Slave code example.
  29          
  30          #define MAX_BUFFER_SIZE              8 // Maximum buffer Master will send
  31          
  32          // Instruction Set
  33          #define  SLAVE_LED_ON             0x01 // Turn the Slave LED on
  34          #define  SLAVE_LED_OFF            0x02 // Turn the Slave LED off
  35          #define  SPI_WRITE                0x04 // Send a byte from the Master to the
  36                                                 // Slave
  37          #define  SPI_READ                 0x08 // Send a byte from the Slave to the
  38                                                 // Master
  39          #define  SPI_WRITE_BUFFER         0x10 // Send a series of bytes from the
  40                                                 // Master to the Slave
  41          #define  SPI_READ_BUFFER          0x20 // Send a series of bytes from the Slave
  42                                                 // to the Master
  43          #define  ERROR_OCCURRED           0x40 // Indicator for the Slave to tell the
  44                                                 // Master an error occurred
  45          #define  SMB_FREQUENCY  30000          // Target SCL clock rate
  46                                                 // This example supports between 10kHz
  47                                                 // and 100kHz
  48          
C51 COMPILER V9.53.0.0   MAIN                                                              01/08/2018 14:24:09 PAGE 2   

  49          #define  WRITE          0x00           // SMBus WRITE command
  50          #define  READ           0x01           // SMBus READ command
  51          
  52          // Device addresses (7 bits, lsb is a don't care)
  53          #define  EEPROM_ADDR    0xA0           // Device address for slave target
  54                                                 // Note: This address is specified
  55                                                 // in the Microchip 24LC02B
  56                                                 // datasheet.
  57          // SMBus Buffer Size
  58          #define  SMB_BUFF_SIZE  0x08           // Defines the maximum number of bytes
  59                                                 // that can be sent or received in a
  60                                                 // single transfer
  61          
  62          // Status vector - top 4 bits only
  63          #define  SMB_MTSTA      0xE0           // (MT) start transmitted
  64          #define  SMB_MTDB       0xC0           // (MT) data byte transmitted
  65          #define  SMB_MRDB       0x80           // (MR) data byte received
  66          
  67          
  68          //-----------------------------------------------------------------------------
  69          // Global Variables
  70          //-----------------------------------------------------------------------------
  71          SI_SEGMENT_VARIABLE(buffer[BUFFER_LENGTH], uint8_t, SI_SEG_XDATA);
  72          SI_SEGMENT_VARIABLE(SPI_TxBuf[MAX_BUFFER_SIZE+1], uint8_t, EFM8PDL_SPI0_TX_SEGTYPE);
  73          SI_SEGMENT_VARIABLE(SPI_RxBuf[MAX_BUFFER_SIZE+1], uint8_t, EFM8PDL_SPI0_RX_SEGTYPE);
  74          
  75          extern uint8_t Uart1_Buffer[5];
  76          extern uint8_t Uart0_Buffer[5];
  77          
  78          
  79          uint8_t* pSMB_DATA_IN;           // Global pointer for SMBus data
  80                                                 // All receive data is written here
  81          
  82          uint8_t SMB_SINGLEBYTE_OUT;      // Global holder for single byte writes.
  83          
  84          uint8_t* pSMB_DATA_OUT;          // Global pointer for SMBus data.
  85                                                 // All transmit data is read from here
  86          
  87          uint8_t SMB_DATA_LEN;            // Global holder for number of bytes
  88                                                 // to send or receive in the current
  89                                                 // SMBus transfer.
  90          
  91          uint8_t WORD_ADDR;               // Global holder for the EEPROM word
  92                                                 // address that will be accessed in
  93                                                 // the next transfer
  94          
  95          uint8_t TARGET;                  // Target SMBus slave address
  96          
  97          bool SMB_BUSY = 0;                      // Software flag to indicate when the
  98                                                 // EEPROM_ByteRead() or
  99                                                 // EEPROM_ByteWrite()
 100                                                 // functions have claimed the SMBus
 101          
 102          bool SMB_RW;                            // Software flag to indicate the
 103                                                 // direction of the current transfer
 104          
 105          bool SMB_SENDWORDADDR;                  // When set, this flag causes the ISR
 106                                                 // to send the 8-bit <WORD_ADDR>
 107                                                 // after sending the slave address.
 108          
 109          bool SMB_RANDOMREAD;                    // When set, this flag causes the ISR
 110                                                 // to send a START signal after sending
 111                                                 // the word address.
C51 COMPILER V9.53.0.0   MAIN                                                              01/08/2018 14:24:09 PAGE 3   

 112                                                 // For the 24LC02B EEPROM, a random read
 113                                                 // (a read from a particular address in
 114                                                 // memory) starts as a write then
 115                                                 // changes to a read after the repeated
 116                                                 // start is sent. The ISR handles this
 117                                                 // switchover if the <SMB_RANDOMREAD>
 118                                                 // bit is set.
 119          
 120          bool SMB_ACKPOLL;                       // When set, this flag causes the ISR
 121                                                 // to send a repeated START until the
 122                                                 // slave has acknowledged its address
 123          
 124          // 16-bit SI_SFR declarations
 125          
 126          SI_SBIT(SDA, SFR_P2, 3);                  // SW1 ='0' means switch pressed
 127          SI_SBIT(SCL, SFR_P2, 4);                  // SW2 ='0' means switch pressed
 128          SI_SBIT(CS, SFR_P1, 1);
 129          
 130          void Delay(void);
 131          
 132          void EEPROM_ByteWrite(uint8_t addr, uint8_t dat);
 133          uint8_t EEPROM_ByteRead(uint8_t addr);
 134          
 135          uint8_t SPI_Transfer_Byte(uint8_t Data);
 136          uint16_t SPI_Transfer_Word(uint8_t addr);
 137          
 138          void UART1_Word_Write(uint16_t Data);
 139          void UART0_Word_Write(uint16_t Data);
 140          
 141          
 142          //-----------------------------------------------------------------------------
 143          // SiLabs_Startup() Routine
 144          // ----------------------------------------------------------------------------
 145          // This function is called immediately after reset, before the initialization
 146          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
 147          // useful place to disable the watchdog timer, which is enable by default
 148          // and may trigger before main() in some instances.
 149          //-----------------------------------------------------------------------------
 150          void SiLabs_Startup (void)
 151          {
 152   1        // Disable the watchdog here
 153   1      }
 154          
 155          //-----------------------------------------------------------------------------
 156          // Main Routine
 157          //-----------------------------------------------------------------------------
 158          void main (void)
 159          {
 160   1         enter_DefaultMode_from_RESET();
 161   1         UART0_init(UART0_RX_ENABLE, UART0_WIDTH_8, UART0_MULTIPROC_DISABLE);
 162   1         SPI0_init(SPI0_CLKMODE_0,true,false);
 163   1      
 164   1         BSP_DISP_EN = BSP_DISP_BC_DRIVEN;   // Display not driven by EFM8
 165   1      
 166   1         BSP_BC_EN = BSP_BC_CONNECTED;       // Board controller connected to EFM8
 167   1                                             // UART pins
 168   1         IE_EA = 1;
 169   1         CS=0;
 170   1      
 171   1         while (1)
 172   1         {
 173   2            if ((UART0_rxBytesRemaining() == 0) && (UART0_txBytesRemaining() == 0))
 174   2            {
C51 COMPILER V9.53.0.0   MAIN                                                              01/08/2018 14:24:09 PAGE 4   

 175   3               UART0_readBuffer(buffer, BUFFER_LENGTH);
 176   3      
 177   3            }
 178   2      
 179   2            if ((UART1_rxBytesRemaining() == 0) && (UART1_txBytesRemaining() == 0))
 180   2            {
 181   3               UART1_readBuffer(buffer, BUFFER_LENGTH);
 182   3            }
 183   2            Delay();
 184   2         }
 185   1      }
 186          
 187          //-----------------------------------------------------------------------------
 188          // UART ISR Callbacks
 189          //-----------------------------------------------------------------------------
 190          void UART0_receiveCompleteCb ()   //UART0 receive interrupter
 191          {
 192   1         //UART0_writeBuffer(buffer, BUFFER_LENGTH);
 193   1      }
 194          
 195          void UART0_transmitCompleteCb ()  //UART0 transmit interrupter
 196          {
 197   1      
 198   1      }
 199          
 200          void UART1_receiveCompleteCb ()  //UART1 receive interrupter
 201          {
 202   1              uint16_t Data;
 203   1              if(Uart1_Buffer[0]==0x55&&Uart1_Buffer[1]==0x00)
 204   1              {
 205   2      
 206   2              }
 207   1              if(Uart1_Buffer[0]==0x55&&Uart1_Buffer[1]==0x01)
 208   1              {
 209   2               Data=SPI_Transfer_Word(Uart1_Buffer[2]);
 210   2               UART1_Word_Write(Data);
 211   2              }
 212   1              else
 213   1              {
 214   2      
 215   2              }
 216   1      }
 217          
 218          void UART1_transmitCompleteCb ()  //UART1 transmit interrupter
 219          {
 220   1      }
 221          
 222          void SPI0_transferCompleteCb(void)    //SPI0 interrupter
 223          {
 224   1      }
 225          
 226          void UART1_Word_Write(uint16_t Data)
 227          {
 228   1              uint8_t high,low;
 229   1              high=Data>>8;
 230   1              low=Data&0x00ff;
 231   1              UART1_write(high);
 232   1          UART1_write(low);
 233   1      }
 234          
 235          void UART0_Word_Write(uint16_t Data)
 236          {
 237   1              uint8_t high,low;
C51 COMPILER V9.53.0.0   MAIN                                                              01/08/2018 14:24:09 PAGE 5   

 238   1          low=Data>>8;
 239   1              high=Data&0x00ff;
 240   1              UART0_write(high);
 241   1          UART0_write(low);
 242   1      }
 243          
 244          uint8_t SPI_Transfer_Byte(uint8_t Data)
 245          {
 246   1              CS=EN;
 247   1              SPI0_writeByte(Data);
 248   1          while(SPI0_isBusy());
 249   1              Data = SPI0DAT;
 250   1              CS=DISEN;
 251   1              return Data;
 252   1      }
 253          
 254          uint16_t SPI_Transfer_Word(uint8_t addr)
 255          {
 256   1              uint8_t high,low;
 257   1              CS=EN;
 258   1          SPI0_writeByte(addr);
 259   1          while(SPI0_isBusy());
 260   1              high = SPI0DAT;
 261   1              SPI0_writeByte(0x00);
 262   1              while(SPI0_isBusy());
 263   1              low = SPI0DAT;
 264   1          CS=DISEN;
 265   1          return (high<<8)|low;
 266   1      }
 267          
 268          //-----------------------------------------------------------------------------
 269          // EEPROM_ByteWrite ()
 270          //-----------------------------------------------------------------------------
 271          //
 272          // Return Value : None
 273          // Parameters   :
 274          //   1) uint8_t addr - address to write in the EEPROM
 275          //                        range is full range of character: 0 to 255
 276          //
 277          //   2) uint8_t dat - data to write to the address <addr> in the EEPROM
 278          //                        range is full range of character: 0 to 255
 279          //
 280          // This function writes the value in <dat> to location <addr> in the EEPROM
 281          // then polls the EEPROM until the write is complete.
 282          //
 283          void EEPROM_ByteWrite(uint8_t addr, uint8_t dat)
 284          {
 285   1         while (SMB_BUSY);                   // Wait for SMBus to be free.
 286   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
 287   1      
 288   1         // Set SMBus ISR parameters
 289   1         TARGET = EEPROM_ADDR;               // Set target slave address
 290   1         SMB_RW = WRITE;                     // Mark next transfer as a write
 291   1         SMB_SENDWORDADDR = 1;               // Send Word Address after Slave Address
 292   1         SMB_RANDOMREAD = 0;                 // Do not send a START signal after
 293   1                                             // the word address
 294   1         SMB_ACKPOLL = 1;                    // Enable Acknowledge Polling (The ISR
 295   1                                             // will automatically restart the
 296   1                                             // transfer if the slave does not
 297   1                                             // acknoledge its address.
 298   1      
 299   1         // Specify the Outgoing Data
 300   1         WORD_ADDR = addr;                   // Set the target address in the
C51 COMPILER V9.53.0.0   MAIN                                                              01/08/2018 14:24:09 PAGE 6   

 301   1                                             // EEPROM's internal memory space
 302   1      
 303   1         SMB_SINGLEBYTE_OUT = dat;           // Store <dat> (local variable) in a
 304   1                                             // global variable so the ISR can read
 305   1                                             // it after this function exits
 306   1      
 307   1         // The outgoing data pointer points to the <dat> variable
 308   1         pSMB_DATA_OUT = &SMB_SINGLEBYTE_OUT;
 309   1      
 310   1         SMB_DATA_LEN = 1;                   // Specify to ISR that the next transfer
 311   1                                             // will contain one data byte
 312   1      
 313   1         // Initiate SMBus Transfer
 314   1         SMB0CN0_STA = 1;
 315   1      
 316   1      }
 317          
 318          //-----------------------------------------------------------------------------
 319          // EEPROM_ByteRead ()
 320          //-----------------------------------------------------------------------------
 321          //
 322          // Return Value :
 323          //   1) uint8_t data - data read from address <addr> in the EEPROM
 324          //                        range is full range of character: 0 to 255
 325          //
 326          // Parameters   :
 327          //   1) uint8_t addr - address to read data from the EEPROM
 328          //                        range is full range of character: 0 to 255
 329          //
 330          // This function returns a single byte from location <addr> in the EEPROM then
 331          // polls the <SMB_BUSY> flag until the read is complete.
 332          //
 333          uint8_t EEPROM_ByteRead(uint8_t addr)
 334          {
 335   1         uint8_t retval;               // Holds the return value
 336   1      
 337   1         while (SMB_BUSY);                   // Wait for SMBus to be free.
 338   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
 339   1      
 340   1         // Set SMBus ISR parameters
 341   1         TARGET = EEPROM_ADDR;               // Set target slave address
 342   1         SMB_RW = WRITE;                     // A random read starts as a write
 343   1                                             // then changes to a read after
 344   1                                             // the repeated start is sent. The
 345   1                                             // ISR handles this switchover if
 346   1                                             // the <SMB_RANDOMREAD> bit is set.
 347   1         SMB_SENDWORDADDR = 1;               // Send Word Address after Slave Address
 348   1         SMB_RANDOMREAD = 1;                 // Send a START after the word address
 349   1         SMB_ACKPOLL = 1;                    // Enable Acknowledge Polling
 350   1      
 351   1         // Specify the Incoming Data
 352   1         WORD_ADDR = addr;                   // Set the target address in the
 353   1                                             // EEPROM's internal memory space
 354   1      
 355   1         pSMB_DATA_IN = &retval;             // The incoming data pointer points to
 356   1                                             // the <retval> variable.
 357   1      
 358   1         SMB_DATA_LEN = 1;                   // Specify to ISR that the next transfer
 359   1                                             // will contain one data byte
 360   1      
 361   1         // Initiate SMBus Transfer
 362   1         SMB0CN0_STA = 1;
 363   1         while(SMB_BUSY);                    // Wait until data is read
C51 COMPILER V9.53.0.0   MAIN                                                              01/08/2018 14:24:09 PAGE 7   

 364   1      
 365   1         return retval;
 366   1      
 367   1      }
 368          void Delay(void)
 369          {
 370   1         uint32_t count;
 371   1      
 372   1         for (count = 200; count > 0; count--);
 373   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    311    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      5    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
