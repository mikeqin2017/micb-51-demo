C51 COMPILER V9.53.0.0   MAIN                                                              12/29/2017 16:36:58 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\src\main.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\shuwen.
                    -ou\SimplicityStudio\v4_workspace\MICB-51\src\main.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(
                    -3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\shuwen.ou\SimplicityStudio\v4_workspac
                    -e\MICB-51\inc;C:\Users\shuwen.ou\SimplicityStudio\v4_workspace\MICB-51\inc\config;C:/SiliconLabs/SimplicityStudio/v4/dev
                    -eloper/sdks/8051/v4.1.1//kits/common/bsp;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//kits/EFM8UB2_SLS
                    -TK2001A/config;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8UB2/peripheral_driver/inc;C:/Si
                    -liconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/de
                    -veloper/sdks/8051/v4.1.1//Device/EFM8UB2/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//kits/common/
                    -drivers/efm8_retargetserial) PRINT(.\src\main.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\main.OBJ)

line level    source

   1          
   2          // Resources:
   3          //   SYSCLK - 48 MHz HFOSC / 4
   4          //   UART0  - 115200 baud, 8-N-1
   5          //   Timer1 - UART0 clock source
   6          //   P0.0   - Board Controller enable
   7          //   P0.4   - UART0 TX
   8          //   P0.5   - UART0 RX
   9          
  10          #include "bsp.h"
  11          #include "uart_0.h"
  12          #include "InitDevice.h"
  13          #include "retargetserial.h"
  14          #include "uart_1.h"
  15          #include "spi_0.h"
  16          
  17          //-----------------------------------------------------------------------------
  18          // Global Constants
  19          //-----------------------------------------------------------------------------
  20          #define BUFFER_LENGTH   5
  21          #define SYSCLK                24500000 // Internal oscillator frequency in Hz
  22          
  23          #define SPI_CLOCK               250000 // Maximum SPI clock
  24                                                 // The SPI clock is a maximum of 1 MHz
  25                                                 // when this example is used with
  26                                                 // the SPI0_Slave code example.
  27          
  28          #define MAX_BUFFER_SIZE              8 // Maximum buffer Master will send
  29          
  30          // Instruction Set
  31          #define  SLAVE_LED_ON             0x01 // Turn the Slave LED on
  32          #define  SLAVE_LED_OFF            0x02 // Turn the Slave LED off
  33          #define  SPI_WRITE                0x04 // Send a byte from the Master to the
  34                                                 // Slave
  35          #define  SPI_READ                 0x08 // Send a byte from the Slave to the
  36                                                 // Master
  37          #define  SPI_WRITE_BUFFER         0x10 // Send a series of bytes from the
  38                                                 // Master to the Slave
  39          #define  SPI_READ_BUFFER          0x20 // Send a series of bytes from the Slave
  40                                                 // to the Master
  41          #define  ERROR_OCCURRED           0x40 // Indicator for the Slave to tell the
  42                                                 // Master an error occurred
  43          #define  SMB_FREQUENCY  30000          // Target SCL clock rate
  44                                                 // This example supports between 10kHz
  45                                                 // and 100kHz
  46          
  47          #define  WRITE          0x00           // SMBus WRITE command
  48          #define  READ           0x01           // SMBus READ command
C51 COMPILER V9.53.0.0   MAIN                                                              12/29/2017 16:36:58 PAGE 2   

  49          
  50          // Device addresses (7 bits, lsb is a don't care)
  51          #define  EEPROM_ADDR    0xA0           // Device address for slave target
  52                                                 // Note: This address is specified
  53                                                 // in the Microchip 24LC02B
  54                                                 // datasheet.
  55          // SMBus Buffer Size
  56          #define  SMB_BUFF_SIZE  0x08           // Defines the maximum number of bytes
  57                                                 // that can be sent or received in a
  58                                                 // single transfer
  59          
  60          // Status vector - top 4 bits only
  61          #define  SMB_MTSTA      0xE0           // (MT) start transmitted
  62          #define  SMB_MTDB       0xC0           // (MT) data byte transmitted
  63          #define  SMB_MRDB       0x80           // (MR) data byte received
  64          
  65          
  66          //-----------------------------------------------------------------------------
  67          // Global Variables
  68          //-----------------------------------------------------------------------------
  69          SI_SEGMENT_VARIABLE(buffer[BUFFER_LENGTH], uint8_t, SI_SEG_XDATA);
  70          SI_SEGMENT_VARIABLE(SPI_TxBuf[MAX_BUFFER_SIZE+1], uint8_t, EFM8PDL_SPI0_TX_SEGTYPE);
  71          SI_SEGMENT_VARIABLE(SPI_RxBuf[MAX_BUFFER_SIZE+1], uint8_t, EFM8PDL_SPI0_RX_SEGTYPE);
  72          
  73          
  74          uint8_t* pSMB_DATA_IN;           // Global pointer for SMBus data
  75                                                 // All receive data is written here
  76          
  77          uint8_t SMB_SINGLEBYTE_OUT;      // Global holder for single byte writes.
  78          
  79          uint8_t* pSMB_DATA_OUT;          // Global pointer for SMBus data.
  80                                                 // All transmit data is read from here
  81          
  82          uint8_t SMB_DATA_LEN;            // Global holder for number of bytes
  83                                                 // to send or receive in the current
  84                                                 // SMBus transfer.
  85          
  86          uint8_t WORD_ADDR;               // Global holder for the EEPROM word
  87                                                 // address that will be accessed in
  88                                                 // the next transfer
  89          
  90          uint8_t TARGET;                  // Target SMBus slave address
  91          
  92          bool SMB_BUSY = 0;                      // Software flag to indicate when the
  93                                                 // EEPROM_ByteRead() or
  94                                                 // EEPROM_ByteWrite()
  95                                                 // functions have claimed the SMBus
  96          
  97          bool SMB_RW;                            // Software flag to indicate the
  98                                                 // direction of the current transfer
  99          
 100          bool SMB_SENDWORDADDR;                  // When set, this flag causes the ISR
 101                                                 // to send the 8-bit <WORD_ADDR>
 102                                                 // after sending the slave address.
 103          
 104          bool SMB_RANDOMREAD;                    // When set, this flag causes the ISR
 105                                                 // to send a START signal after sending
 106                                                 // the word address.
 107                                                 // For the 24LC02B EEPROM, a random read
 108                                                 // (a read from a particular address in
 109                                                 // memory) starts as a write then
 110                                                 // changes to a read after the repeated
 111                                                 // start is sent. The ISR handles this
C51 COMPILER V9.53.0.0   MAIN                                                              12/29/2017 16:36:58 PAGE 3   

 112                                                 // switchover if the <SMB_RANDOMREAD>
 113                                                 // bit is set.
 114          
 115          bool SMB_ACKPOLL;                       // When set, this flag causes the ISR
 116                                                 // to send a repeated START until the
 117                                                 // slave has acknowledged its address
 118          
 119          // 16-bit SI_SFR declarations
 120          
 121          SI_SBIT(SDA, SFR_P2, 3);                  // SW1 ='0' means switch pressed
 122          SI_SBIT(SCL, SFR_P2, 4);                  // SW2 ='0' means switch pressed
 123          SI_SBIT(CS, SFR_P1, 1);
 124          
 125          void SPI_Byte_Write (uint8_t writeData);
 126          uint8_t SPI_Byte_Read(uint8_t writeData);
 127          void Delay(void);
 128          void EEPROM_ByteWrite(uint8_t addr, uint8_t dat);
 129          uint8_t EEPROM_ByteRead(uint8_t addr);
 130          
 131          
 132          
 133          //-----------------------------------------------------------------------------
 134          // SiLabs_Startup() Routine
 135          // ----------------------------------------------------------------------------
 136          // This function is called immediately after reset, before the initialization
 137          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
 138          // useful place to disable the watchdog timer, which is enable by default
 139          // and may trigger before main() in some instances.
 140          //-----------------------------------------------------------------------------
 141          void SiLabs_Startup (void)
 142          {
 143   1        // Disable the watchdog here
 144   1      }
 145          
 146          //-----------------------------------------------------------------------------
 147          // Main Routine
 148          //-----------------------------------------------------------------------------
 149          void main (void)
 150          {
 151   1              uint8_t Data1,Data2;
 152   1         enter_DefaultMode_from_RESET();
 153   1         UART0_init(UART0_RX_ENABLE, UART0_WIDTH_8, UART0_MULTIPROC_DISABLE);
 154   1         SPI0_init(SPI0_CLKMODE_0,true,false);
 155   1      
 156   1         BSP_DISP_EN = BSP_DISP_BC_DRIVEN;   // Display not driven by EFM8
 157   1      
 158   1         BSP_BC_EN = BSP_BC_CONNECTED;       // Board controller connected to EFM8
 159   1                                             // UART pins
 160   1         IE_EA = 1;
 161   1         CS=0;
 162   1      
 163   1         while (1)
 164   1         {
 165   2            if ((UART0_rxBytesRemaining() == 0) && (UART0_txBytesRemaining() == 0))
 166   2            {
 167   3               UART0_readBuffer(buffer, BUFFER_LENGTH);
 168   3            }
 169   2      
 170   2            if ((UART1_rxBytesRemaining() == 0) && (UART1_txBytesRemaining() == 0))
 171   2            {
 172   3               UART1_readBuffer(buffer, BUFFER_LENGTH);
 173   3            }
 174   2            /*SPI_Byte_Write(0x80);
C51 COMPILER V9.53.0.0   MAIN                                                              12/29/2017 16:36:58 PAGE 4   

 175   2            SPI_Byte_Write(0x0);*/
 176   2            CS=1;
 177   2            SPI0_writeByte(0x80);
 178   2            Data1 = SPI0DAT;
 179   2            SPI0_writeByte(0x00);
 180   2            Data2 = SPI0DAT;
 181   2            while(SPI0_isBusy());
 182   2            CS=0;
 183   2      
 184   2            Delay();
 185   2         }
 186   1      }
 187          
 188          //-----------------------------------------------------------------------------
 189          // UART ISR Callbacks
 190          //-----------------------------------------------------------------------------
 191          void UART0_receiveCompleteCb ()   //UART0 receive interrupter
 192          {
 193   1         UART0_writeBuffer(buffer, BUFFER_LENGTH);
 194   1      
 195   1      }
 196          
 197          void UART0_transmitCompleteCb ()  //UART0 transmit interrupter
 198          {
 199   1      
 200   1      }
 201          
 202          void UART1_receiveCompleteCb ()  //UART1 receive interrupter
 203          {
 204   1              uint8_t data1,data2;
 205   1              if(buffer[0]==0x55&&buffer[1]==0x00)
 206   1              {
 207   2                      SPI_Byte_Write(buffer[2]);
 208   2              }
 209   1              if(buffer[0]==0x55&&buffer[1]==0x01)
 210   1              {
 211   2               data1=SPI_Byte_Read(buffer[2]);
 212   2               data1=SPI_Byte_Read(0);
 213   2               UART1_write(data1);
 214   2               UART1_write(data2);
 215   2              }
 216   1              else
 217   1              {
 218   2      
 219   2              }
 220   1         //UART1_writeBuffer(buffer, BUFFER_LENGTH);
 221   1      }
 222          
 223          void UART1_transmitCompleteCb ()  //UART1 transmit interrupter
 224          {
 225   1      }
 226          
 227          void SPI0_transferCompleteCb(void)    //SPI0 interrupter
 228          {
 229   1      }
 230          
 231          
 232          void SPI_Byte_Write(uint8_t writeData)
 233          {
 234   1            CS=1;
 235   1            SPI0_writeByte(writeData);
 236   1            while(SPI0_isBusy());
 237   1            CS=0;
C51 COMPILER V9.53.0.0   MAIN                                                              12/29/2017 16:36:58 PAGE 5   

 238   1      }
 239          
 240          //-----------------------------------------------------------------------------
 241          // SPI_Byte_Read
 242          //-----------------------------------------------------------------------------
 243          //
 244          // Return Value : The byte read from the slave
 245          // Parameters   : None
 246          //
 247          // Reads a single byte from the SPI Slave.  The command consists of:
 248          //
 249          // Command = SPI_READ
 250          // Length = 1 byte of command, 1 byte of data
 251          //
 252          //-----------------------------------------------------------------------------
 253          uint8_t SPI_Byte_Read(uint8_t writeData)
 254          {
 255   1               uint8_t Data;
 256   1      
 257   1           CS=1;
 258   1           SPI0_writeByte(writeData);
 259   1           while(SPI0_isBusy());
 260   1           CS=0;
 261   1           if(SPI0CN0_SPIF)
 262   1           {
 263   2               Data = SPI0DAT;
 264   2           }
 265   1           return Data;
 266   1      }
 267          
 268          //-----------------------------------------------------------------------------
 269          // EEPROM_ByteWrite ()
 270          //-----------------------------------------------------------------------------
 271          //
 272          // Return Value : None
 273          // Parameters   :
 274          //   1) uint8_t addr - address to write in the EEPROM
 275          //                        range is full range of character: 0 to 255
 276          //
 277          //   2) uint8_t dat - data to write to the address <addr> in the EEPROM
 278          //                        range is full range of character: 0 to 255
 279          //
 280          // This function writes the value in <dat> to location <addr> in the EEPROM
 281          // then polls the EEPROM until the write is complete.
 282          //
 283          void EEPROM_ByteWrite(uint8_t addr, uint8_t dat)
 284          {
 285   1         while (SMB_BUSY);                   // Wait for SMBus to be free.
 286   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
 287   1      
 288   1         // Set SMBus ISR parameters
 289   1         TARGET = EEPROM_ADDR;               // Set target slave address
 290   1         SMB_RW = WRITE;                     // Mark next transfer as a write
 291   1         SMB_SENDWORDADDR = 1;               // Send Word Address after Slave Address
 292   1         SMB_RANDOMREAD = 0;                 // Do not send a START signal after
 293   1                                             // the word address
 294   1         SMB_ACKPOLL = 1;                    // Enable Acknowledge Polling (The ISR
 295   1                                             // will automatically restart the
 296   1                                             // transfer if the slave does not
 297   1                                             // acknoledge its address.
 298   1      
 299   1         // Specify the Outgoing Data
 300   1         WORD_ADDR = addr;                   // Set the target address in the
C51 COMPILER V9.53.0.0   MAIN                                                              12/29/2017 16:36:58 PAGE 6   

 301   1                                             // EEPROM's internal memory space
 302   1      
 303   1         SMB_SINGLEBYTE_OUT = dat;           // Store <dat> (local variable) in a
 304   1                                             // global variable so the ISR can read
 305   1                                             // it after this function exits
 306   1      
 307   1         // The outgoing data pointer points to the <dat> variable
 308   1         pSMB_DATA_OUT = &SMB_SINGLEBYTE_OUT;
 309   1      
 310   1         SMB_DATA_LEN = 1;                   // Specify to ISR that the next transfer
 311   1                                             // will contain one data byte
 312   1      
 313   1         // Initiate SMBus Transfer
 314   1         SMB0CN0_STA = 1;
 315   1      
 316   1      }
 317          
 318          //-----------------------------------------------------------------------------
 319          // EEPROM_ByteRead ()
 320          //-----------------------------------------------------------------------------
 321          //
 322          // Return Value :
 323          //   1) uint8_t data - data read from address <addr> in the EEPROM
 324          //                        range is full range of character: 0 to 255
 325          //
 326          // Parameters   :
 327          //   1) uint8_t addr - address to read data from the EEPROM
 328          //                        range is full range of character: 0 to 255
 329          //
 330          // This function returns a single byte from location <addr> in the EEPROM then
 331          // polls the <SMB_BUSY> flag until the read is complete.
 332          //
 333          uint8_t EEPROM_ByteRead(uint8_t addr)
 334          {
 335   1         uint8_t retval;               // Holds the return value
 336   1      
 337   1         while (SMB_BUSY);                   // Wait for SMBus to be free.
 338   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
 339   1      
 340   1         // Set SMBus ISR parameters
 341   1         TARGET = EEPROM_ADDR;               // Set target slave address
 342   1         SMB_RW = WRITE;                     // A random read starts as a write
 343   1                                             // then changes to a read after
 344   1                                             // the repeated start is sent. The
 345   1                                             // ISR handles this switchover if
 346   1                                             // the <SMB_RANDOMREAD> bit is set.
 347   1         SMB_SENDWORDADDR = 1;               // Send Word Address after Slave Address
 348   1         SMB_RANDOMREAD = 1;                 // Send a START after the word address
 349   1         SMB_ACKPOLL = 1;                    // Enable Acknowledge Polling
 350   1      
 351   1         // Specify the Incoming Data
 352   1         WORD_ADDR = addr;                   // Set the target address in the
 353   1                                             // EEPROM's internal memory space
 354   1      
 355   1         pSMB_DATA_IN = &retval;             // The incoming data pointer points to
 356   1                                             // the <retval> variable.
 357   1      
 358   1         SMB_DATA_LEN = 1;                   // Specify to ISR that the next transfer
 359   1                                             // will contain one data byte
 360   1      
 361   1         // Initiate SMBus Transfer
 362   1         SMB0CN0_STA = 1;
 363   1         while(SMB_BUSY);                    // Wait until data is read
C51 COMPILER V9.53.0.0   MAIN                                                              12/29/2017 16:36:58 PAGE 7   

 364   1      
 365   1         return retval;
 366   1      
 367   1      }
 368          void Delay(void)
 369          {
 370   1         uint32_t count;
 371   1      
 372   1         for (count = 200; count > 0; count--);
 373   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    326    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      5    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
