C51 COMPILER V9.53.0.0   UART_1                                                            01/08/2018 14:24:10 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE UART_1
OBJECT MODULE PLACED IN .\lib\efm8ub2\peripheralDrivers\src\uart_1.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\SiliconLabs\S
                    -implicityStudio\v4\developer\sdks\8051\v4.1.1\Device\EFM8UB2\peripheral_driver\src\uart_1.c OMF2 SMALL DEBUG OBJECTEXTEN
                    -D ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\User
                    -s\shuwen.ou\SimplicityStudio\v4_workspace\MICB-51\inc;C:\Users\shuwen.ou\SimplicityStudio\v4_workspace\MICB-51\inc\confi
                    -g;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//kits/common/bsp;C:/SiliconLabs/SimplicityStudio/v4/deve
                    -loper/sdks/8051/v4.1.1//kits/EFM8UB2_SLSTK2001A/config;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//De
                    -vice/EFM8UB2/peripheral_driver/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/shared/si8051ba
                    -se;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8UB2/inc;C:/SiliconLabs/SimplicityStudio/v4/
                    -developer/sdks/8051/v4.1.1//kits/common/drivers/efm8_retargetserial) PRINT(.\lib\efm8ub2\peripheralDrivers\src\uart_1.ls
                    -t) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\lib\efm8ub2\peripheralDrivers\src\uart_1.OBJ)

line level    source

   1          /**************************************************************************//**
   2           * Copyright (c) 2016 by Silicon Laboratories Inc. All rights reserved.
   3           *
   4           * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5           *****************************************************************************/
   6          
   7          #include "uart_1.h"
   8          
   9          // Clock prescaler values for baud rate initialization
  10          #define NUM_PRESC 4
  11          static const uint8_t PRESC[NUM_PRESC]      = {1, 4, 12, 48};
  12          static const uint8_t PRESC_ENUM[NUM_PRESC] = {SBCON1_BPS__DIV_BY_1,  SBCON1_BPS__DIV_BY_4, SBCON1_BPS__DIV
             -_BY_12, SBCON1_BPS__DIV_BY_48};
  13          static void UART1_initBaudRate(uint32_t sysclk, uint32_t baudrate)
  14          {
  15   1        uint8_t i;
  16   1        uint8_t min_presc;
  17   1        uint16_t reload;
  18   1      
  19   1        // Calculate baud rate prescaler and baud rate reload
  20   1        // value to maximize precision.
  21   1        // See reference manual for calculation details
  22   1        min_presc = ((*((uint16_t*)(&sysclk)) >> 1) + baudrate) / baudrate; // calculate minimum prescaler neces
             -sary
  23   1        for(i = 0; i < NUM_PRESC; ++i)
  24   1        {
  25   2          if(PRESC[i] >= min_presc) // use a prescaler that is equal or just greater than the minimum
  26   2          {
  27   3            reload =  ((1 << 16) - (sysclk / (2 * baudrate * PRESC[i]))); // calculate reload value using presca
             -ler
  28   3            SBRL1  = reload;
  29   3            SBCON1 |= (SBCON1_BREN__ENABLED | PRESC_ENUM[i]); // enable baud rate with calculated prescaler
  30   3            return;
  31   3          }
  32   2        }
  33   1      
  34   1        // Baud rate is too small to be match
  35   1        while(1);
  36   1      }
  37          
  38          //=========================================================
  39          // Runtime API
  40          //=========================================================
  41          
  42          uint8_t UART1_getIntFlags(void)
  43          {
  44   1        return SCON1 & (UART1_TX_IF | UART1_RX_IF);
C51 COMPILER V9.53.0.0   UART_1                                                            01/08/2018 14:24:10 PAGE 2   

  45   1      }
  46          
  47          void UART1_clearIntFlags(uint8_t flags)
  48          {
  49   1        SCON1 &= ~flags;
  50   1      }
  51          
  52          void UART1_initTxPolling(void)
  53          {
  54   1        SCON1 |= SCON1_TI__SET;
  55   1      }
  56          
  57          void UART1_write(uint8_t value)
  58          {
  59   1        SBUF1 = value;
  60   1      }
  61          
  62          uint8_t UART1_read(void)
  63          {
  64   1        return SBUF1;
  65   1      }
  66          
  67          void UART1_writeWithExtraBit(uint16_t value)
  68          {
  69   1        uint8_t shift, mask;
  70   1      
  71   1        // Calculate shift and mask for data length
  72   1        shift = ((SMOD1 & SMOD1_SDL__FMASK) >> SMOD1_SDL__SHIFT) + 2;
  73   1        mask = 0xFF >> (5 - shift);
  74   1      
  75   1        SCON1 &= ~SCON1_TBX__BMASK;
  76   1        SCON1 |= ((value >> shift) & SCON1_TBX__BMASK);
  77   1        SBUF1 = (value & mask);
  78   1      }
  79          
  80          uint16_t UART1_readWithExtraBit(void)
  81          {
  82   1        uint8_t shift, mask;
  83   1        uint16_t val;
  84   1      
  85   1        // Calculate shift and mask for data length
  86   1        shift = ((SMOD1 & SMOD1_SDL__FMASK) >> SMOD1_SDL__SHIFT) + 3;
  87   1        mask = 0xFF >> (6 - shift);
  88   1      
  89   1        val = SCON1 & SCON1_RBX__BMASK;
  90   1        val = val << shift;
  91   1        val |= (SBUF1 & mask);
  92   1      
  93   1        return val;
  94   1      }
  95          
  96          uint8_t UART1_getErrFlags(void)
  97          {
  98   1        return SCON1 & (UART1_RXOVR_EF | UART1_PARITY_EF);
  99   1      }
 100          
 101          void UART1_clearErrFlags(uint8_t flags)
 102          {
 103   1        SCON1 &= ~flags;
 104   1      }
 105          
 106          //=========================================================
 107          // Initialization API
C51 COMPILER V9.53.0.0   UART_1                                                            01/08/2018 14:24:10 PAGE 3   

 108          //=========================================================
 109          
 110          void UART1_init(uint32_t sysclk, uint32_t baudrate,
 111                          UART1_DataLen_t datalen, UART1_StopLen_t stoplen,
 112                          UART1_FeatureBit_t featbit, UART1_ParityType_t partype,
 113                          UART1_RxEnable_t rxen, UART1_Multiproc_t mcen)
 114          {
 115   1        UART1_initBaudRate(sysclk, baudrate);
 116   1        SCON1 = rxen;
 117   1        SMOD1 = datalen | stoplen | featbit | partype | mcen;
 118   1      }
 119          
 120          void UART1_reset(void)
 121          {
 122   1        SCON1 = SCON1_OVR__NOT_SET
 123   1                | SCON1_PERR__NOT_SET
 124   1                | SCON1_REN__RECEIVE_DISABLED
 125   1                | SCON1_TBX__LOW
 126   1                | SCON1_RBX__LOW
 127   1                | SCON1_TI__NOT_SET
 128   1                | SCON1_RI__NOT_SET;
 129   1        SMOD1 = SMOD1_MCE__MULTI_DISABLED
 130   1                | SMOD1_SPT__ODD_PARITY
 131   1                | SMOD1_PE__PARITY_DISABLED
 132   1                | SMOD1_SDL__8_BITS
 133   1                | SMOD1_XBE__DISABLED
 134   1                | SMOD1_SBL__SHORT;
 135   1        SBCON1 = SBCON1_BREN__DISABLED
 136   1                 | SBCON1_BPS__DIV_BY_1;
 137   1      }
 138          
 139          //=========================================================
 140          // Buffer Access API
 141          //=========================================================
 142          #if EFM8PDL_UART1_USE_BUFFER == 1
 143          
 144          SI_SEGMENT_VARIABLE(txRemaining, static uint8_t, SI_SEG_XDATA) = 0;
 145          SI_SEGMENT_VARIABLE(rxRemaining, static uint8_t, SI_SEG_XDATA) = 0;
 146          SI_SEGMENT_VARIABLE_SEGMENT_POINTER(txBuffer, static uint8_t, EFM8PDL_UART1_TX_BUFTYPE, SI_SEG_XDATA);
 147          SI_SEGMENT_VARIABLE_SEGMENT_POINTER(rxBuffer, static uint8_t, EFM8PDL_UART1_RX_BUFTYPE, SI_SEG_XDATA);
 148          
 149          uint8_t Uart1_Buffer[5];
 150          
 151          SI_INTERRUPT(UART1_ISR, UART1_IRQn)
 152          {
 153   1        uint8_t discard;
 154   1        static uint8_t i;
 155   1      #if (EFM8PDL_UART1_USE_ERR_CALLBACK == 1)
                uint8_t errors;
              #endif //EFM8PDL_UART1_USE_ERR_CALLBACK
 158   1      
 159   1        // Read bytes as long as rx fifo is not empty
 160   1        while (SCON1 & UART1_RX_IF)
 161   1        {
 162   2          SCON1 &= ~UART1_RX_IF;
 163   2      
 164   2      #if (EFM8PDL_UART1_USE_ERR_CALLBACK == 1)
                  // If parity or overrun error, clear flags, and call user
                  errors = SCON1 & (UART1_RXOVR_EF | UART1_PARITY_EF);
                  if(errors)
                  {
                    SCON1 &= ~errors;
                    UART1_transferErrorCb(errors);
C51 COMPILER V9.53.0.0   UART_1                                                            01/08/2018 14:24:10 PAGE 4   

                  }
              
                  // Store byte if there is room in rx buffer and no parity error
                  if (rxRemaining && !(errors & UART1_PARITY_EF))
              #else
 176   2          // Store byte if there is room in rx buffer
 177   2          if (rxRemaining)
 178   2      #endif //EFM8PDL_UART1_USE_ERR_CALLBACK
 179   2          {
 180   3            *rxBuffer = SBUF1;
 181   3            Uart1_Buffer[i]=*rxBuffer;
 182   3            if(++i==5)i=0;
 183   3            ++rxBuffer;
 184   3            --rxRemaining;
 185   3            if (!rxRemaining)
 186   3            {
 187   4              /*for(i=0;i<5;i++)
 188   4              {
 189   4                      BU[i]=rxBuffer[i];
 190   4              }*/
 191   4              UART1_receiveCompleteCb();
 192   4            }
 193   3          }
 194   2          // Discard byte if there is no room available in rx buffer (or parity error)
 195   2          else
 196   2          {
 197   3                discard = SBUF1;
 198   3          }
 199   2      
 200   2          // Work around for receive FIFO collision error. If SBUF1 is read as a new
 201   2          // stop bit is received, OVR is set and the FIFO read pointer does not update.
 202   2          // Since we just cleared OVR then read SBUF1, OVR now indicates that a FIFO
 203   2          // collision occurred. If so, clear the error and pop the FIFO to update its
 204   2          // read pointer.
 205   2          if (SCON1 & UART1_RXOVR_EF)
 206   2          {
 207   3            SCON1 &= ~UART1_RXOVR_EF;
 208   3            discard = SBUF1;
 209   3          }
 210   2        }
 211   1          
 212   1        // If previous byte has been transmitted
 213   1        if (SCON1 & UART1_TX_IF)
 214   1        {
 215   2              SCON1 &= ~UART1_TX_IF;
 216   2      
 217   2          // Write byte if there is room in the tx buffer
 218   2          if (txRemaining)
 219   2          {
 220   3            SBUF1 = *txBuffer;
 221   3            ++txBuffer;
 222   3            --txRemaining;
 223   3          }
 224   2          else
 225   2          {
 226   3            UART1_transmitCompleteCb();
 227   3          }
 228   2        }
 229   1      }
 230          
 231          void UART1_writeBuffer(SI_VARIABLE_SEGMENT_POINTER(buffer, uint8_t, EFM8PDL_UART1_RX_BUFTYPE),
 232                                 uint8_t length)
 233          {
C51 COMPILER V9.53.0.0   UART_1                                                            01/08/2018 14:24:10 PAGE 5   

 234   1        // Initialize internal data
 235   1        txBuffer = buffer + 1;
 236   1        txRemaining = length - 1;
 237   1      
 238   1        //Send initial byte
 239   1        SBUF1 = *buffer;
 240   1      }
 241          
 242          void UART1_readBuffer(SI_VARIABLE_SEGMENT_POINTER(buffer, uint8_t, EFM8PDL_UART1_TX_BUFTYPE),
 243                                uint8_t length)
 244          {
 245   1        // Initialize internal data
 246   1        rxBuffer = buffer;
 247   1        rxRemaining = length;
 248   1      }
 249          
 250          void UART1_abortTx(void)
 251          {
 252   1        txRemaining = 0;
 253   1      }
 254          
 255          void UART1_abortRx(void)
 256          {
 257   1        rxRemaining = 0;
 258   1      }
 259          
 260          uint8_t UART1_txBytesRemaining(void)
 261          {
 262   1        return txRemaining;
 263   1      }
 264          
 265          uint8_t UART1_rxBytesRemaining(void)
 266          {
 267   1        return rxRemaining;
 268   1      }
 269          
 270          #endif //EFM8PDL_UART1_USE_BUFFER
 271          
 272          //=========================================================
 273          // STDIO API
 274          //=========================================================
 275          #if EFM8PDL_UART1_USE_STDIO == 1
              char putchar(char c){
                while(!(SCON1 & SCON1_TI__SET));
                SBUF1 = c;
                SCON1 &= ~SCON1_TI__SET;
                return c;
              }
              
              char _getkey(void){
                while(!(SCON1 & SCON1_RI__SET));
                SCON1 &= ~SCON1_RI__SET;
                return SBUF1;
              }
              
              void UART1_initStdio(uint32_t sysclk, uint32_t baudrate)
              {
                SCON1  |= SCON1_REN__RECEIVE_ENABLED | SCON1_TI__SET;
                SMOD1  |= SMOD1_SDL__8_BITS;
                UART1_initBaudRate(sysclk, baudrate);
              }
              
              #endif //EFM8PDL_UART0_USE_STDIO
C51 COMPILER V9.53.0.0   UART_1                                                            01/08/2018 14:24:10 PAGE 6   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    621    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      6    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      25
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
