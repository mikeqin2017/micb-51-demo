C51 COMPILER V9.53.0.0   UART_1                                                            12/29/2017 16:10:08 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE UART_1
OBJECT MODULE PLACED IN .\lib\efm8ub2\peripheralDrivers\src\uart_1.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\SiliconLabs\S
                    -implicityStudio\v4\developer\sdks\8051\v4.1.1\Device\EFM8UB2\peripheral_driver\src\uart_1.c OMF2 SMALL DEBUG OBJECTEXTEN
                    -D ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\User
                    -s\shuwen.ou\SimplicityStudio\v4_workspace\MICB-51\inc;C:\Users\shuwen.ou\SimplicityStudio\v4_workspace\MICB-51\inc\confi
                    -g;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//kits/common/bsp;C:/SiliconLabs/SimplicityStudio/v4/deve
                    -loper/sdks/8051/v4.1.1//kits/EFM8UB2_SLSTK2001A/config;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//De
                    -vice/EFM8UB2/peripheral_driver/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/shared/si8051ba
                    -se;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8UB2/inc;C:/SiliconLabs/SimplicityStudio/v4/
                    -developer/sdks/8051/v4.1.1//kits/common/drivers/efm8_retargetserial) PRINT(.\lib\efm8ub2\peripheralDrivers\src\uart_1.ls
                    -t) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\lib\efm8ub2\peripheralDrivers\src\uart_1.OBJ)

line level    source

   1          /**************************************************************************//**
   2           * Copyright (c) 2016 by Silicon Laboratories Inc. All rights reserved.
   3           *
   4           * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5           *****************************************************************************/
   6          
   7          #include "uart_1.h"
   8          
   9          // Clock prescaler values for baud rate initialization
  10          #define NUM_PRESC 4
  11          static const uint8_t PRESC[NUM_PRESC]      = {1, 4, 12, 48};
  12          static const uint8_t PRESC_ENUM[NUM_PRESC] = {SBCON1_BPS__DIV_BY_1,  SBCON1_BPS__DIV_BY_4, SBCON1_BPS__DIV
             -_BY_12, SBCON1_BPS__DIV_BY_48};
  13          static void UART1_initBaudRate(uint32_t sysclk, uint32_t baudrate)
  14          {
  15   1        uint8_t i;
  16   1        uint8_t min_presc;
  17   1        uint16_t reload;
  18   1      
  19   1        // Calculate baud rate prescaler and baud rate reload
  20   1        // value to maximize precision.
  21   1        // See reference manual for calculation details
  22   1        min_presc = ((*((uint16_t*)(&sysclk)) >> 1) + baudrate) / baudrate; // calculate minimum prescaler neces
             -sary
  23   1        for(i = 0; i < NUM_PRESC; ++i)
  24   1        {
  25   2          if(PRESC[i] >= min_presc) // use a prescaler that is equal or just greater than the minimum
  26   2          {
  27   3            reload =  ((1 << 16) - (sysclk / (2 * baudrate * PRESC[i]))); // calculate reload value using presca
             -ler
  28   3            SBRL1  = reload;
  29   3            SBCON1 |= (SBCON1_BREN__ENABLED | PRESC_ENUM[i]); // enable baud rate with calculated prescaler
  30   3            return;
  31   3          }
  32   2        }
  33   1      
  34   1        // Baud rate is too small to be match
  35   1        while(1);
  36   1      }
  37          
  38          //=========================================================
  39          // Runtime API
  40          //=========================================================
  41          
  42          uint8_t UART1_getIntFlags(void)
  43          {
  44   1        return SCON1 & (UART1_TX_IF | UART1_RX_IF);
C51 COMPILER V9.53.0.0   UART_1                                                            12/29/2017 16:10:08 PAGE 2   

  45   1      }
  46          
  47          void UART1_clearIntFlags(uint8_t flags)
  48          {
  49   1        SCON1 &= ~flags;
  50   1      }
  51          
  52          void UART1_initTxPolling(void)
  53          {
  54   1        SCON1 |= SCON1_TI__SET;
  55   1      }
  56          
  57          void UART1_write(uint8_t value)
  58          {
  59   1        SBUF1 = value;
  60   1      }
  61          
  62          uint8_t UART1_read(void)
  63          {
  64   1        return SBUF1;
  65   1      }
  66          
  67          void UART1_writeWithExtraBit(uint16_t value)
  68          {
  69   1        uint8_t shift, mask;
  70   1      
  71   1        // Calculate shift and mask for data length
  72   1        shift = ((SMOD1 & SMOD1_SDL__FMASK) >> SMOD1_SDL__SHIFT) + 2;
  73   1        mask = 0xFF >> (5 - shift);
  74   1      
  75   1        SCON1 &= ~SCON1_TBX__BMASK;
  76   1        SCON1 |= ((value >> shift) & SCON1_TBX__BMASK);
  77   1        SBUF1 = (value & mask);
  78   1      }
  79          
  80          uint16_t UART1_readWithExtraBit(void)
  81          {
  82   1        uint8_t shift, mask;
  83   1        uint16_t val;
  84   1      
  85   1        // Calculate shift and mask for data length
  86   1        shift = ((SMOD1 & SMOD1_SDL__FMASK) >> SMOD1_SDL__SHIFT) + 3;
  87   1        mask = 0xFF >> (6 - shift);
  88   1      
  89   1        val = SCON1 & SCON1_RBX__BMASK;
  90   1        val = val << shift;
  91   1        val |= (SBUF1 & mask);
  92   1      
  93   1        return val;
  94   1      }
  95          
  96          uint8_t UART1_getErrFlags(void)
  97          {
  98   1        return SCON1 & (UART1_RXOVR_EF | UART1_PARITY_EF);
  99   1      }
 100          
 101          void UART1_clearErrFlags(uint8_t flags)
 102          {
 103   1        SCON1 &= ~flags;
 104   1      }
 105          
 106          //=========================================================
 107          // Initialization API
C51 COMPILER V9.53.0.0   UART_1                                                            12/29/2017 16:10:08 PAGE 3   

 108          //=========================================================
 109          
 110          void UART1_init(uint32_t sysclk, uint32_t baudrate,
 111                          UART1_DataLen_t datalen, UART1_StopLen_t stoplen,
 112                          UART1_FeatureBit_t featbit, UART1_ParityType_t partype,
 113                          UART1_RxEnable_t rxen, UART1_Multiproc_t mcen)
 114          {
 115   1        UART1_initBaudRate(sysclk, baudrate);
 116   1        SCON1 = rxen;
 117   1        SMOD1 = datalen | stoplen | featbit | partype | mcen;
 118   1      }
 119          
 120          void UART1_reset(void)
 121          {
 122   1        SCON1 = SCON1_OVR__NOT_SET
 123   1                | SCON1_PERR__NOT_SET
 124   1                | SCON1_REN__RECEIVE_DISABLED
 125   1                | SCON1_TBX__LOW
 126   1                | SCON1_RBX__LOW
 127   1                | SCON1_TI__NOT_SET
 128   1                | SCON1_RI__NOT_SET;
 129   1        SMOD1 = SMOD1_MCE__MULTI_DISABLED
 130   1                | SMOD1_SPT__ODD_PARITY
 131   1                | SMOD1_PE__PARITY_DISABLED
 132   1                | SMOD1_SDL__8_BITS
 133   1                | SMOD1_XBE__DISABLED
 134   1                | SMOD1_SBL__SHORT;
 135   1        SBCON1 = SBCON1_BREN__DISABLED
 136   1                 | SBCON1_BPS__DIV_BY_1;
 137   1      }
 138          
 139          //=========================================================
 140          // Buffer Access API
 141          //=========================================================
 142          #if EFM8PDL_UART1_USE_BUFFER == 1
 143          
 144          SI_SEGMENT_VARIABLE(txRemaining, static uint8_t, SI_SEG_XDATA) = 0;
 145          SI_SEGMENT_VARIABLE(rxRemaining, static uint8_t, SI_SEG_XDATA) = 0;
 146          SI_SEGMENT_VARIABLE_SEGMENT_POINTER(txBuffer, static uint8_t, EFM8PDL_UART1_TX_BUFTYPE, SI_SEG_XDATA);
 147          SI_SEGMENT_VARIABLE_SEGMENT_POINTER(rxBuffer, static uint8_t, EFM8PDL_UART1_RX_BUFTYPE, SI_SEG_XDATA);
 148          
 149          SI_INTERRUPT(UART1_ISR, UART1_IRQn)
 150          {
 151   1        uint8_t discard;
 152   1      #if (EFM8PDL_UART1_USE_ERR_CALLBACK == 1)
                uint8_t errors;
              #endif //EFM8PDL_UART1_USE_ERR_CALLBACK
 155   1      
 156   1        // Read bytes as long as rx fifo is not empty
 157   1        while (SCON1 & UART1_RX_IF)
 158   1        {
 159   2          SCON1 &= ~UART1_RX_IF;
 160   2      
 161   2      #if (EFM8PDL_UART1_USE_ERR_CALLBACK == 1)
                  // If parity or overrun error, clear flags, and call user
                  errors = SCON1 & (UART1_RXOVR_EF | UART1_PARITY_EF);
                  if(errors)
                  {
                    SCON1 &= ~errors;
                    UART1_transferErrorCb(errors);
                  }
              
                  // Store byte if there is room in rx buffer and no parity error
C51 COMPILER V9.53.0.0   UART_1                                                            12/29/2017 16:10:08 PAGE 4   

                  if (rxRemaining && !(errors & UART1_PARITY_EF))
              #else
 173   2          // Store byte if there is room in rx buffer
 174   2          if (rxRemaining)
 175   2      #endif //EFM8PDL_UART1_USE_ERR_CALLBACK
 176   2          {
 177   3            *rxBuffer = SBUF1;
 178   3            ++rxBuffer;
 179   3            --rxRemaining;
 180   3            if (!rxRemaining)
 181   3            {
 182   4              UART1_receiveCompleteCb();
 183   4            }
 184   3          }
 185   2          // Discard byte if there is no room available in rx buffer (or parity error)
 186   2          else
 187   2          {
 188   3                discard = SBUF1;
 189   3          }
 190   2      
 191   2          // Work around for receive FIFO collision error. If SBUF1 is read as a new
 192   2          // stop bit is received, OVR is set and the FIFO read pointer does not update.
 193   2          // Since we just cleared OVR then read SBUF1, OVR now indicates that a FIFO
 194   2          // collision occurred. If so, clear the error and pop the FIFO to update its
 195   2          // read pointer.
 196   2          if (SCON1 & UART1_RXOVR_EF)
 197   2          {
 198   3            SCON1 &= ~UART1_RXOVR_EF;
 199   3            discard = SBUF1;
 200   3          }
 201   2        }
 202   1          
 203   1        // If previous byte has been transmitted
 204   1        if (SCON1 & UART1_TX_IF)
 205   1        {
 206   2              SCON1 &= ~UART1_TX_IF;
 207   2      
 208   2          // Write byte if there is room in the tx buffer
 209   2          if (txRemaining)
 210   2          {
 211   3            SBUF1 = *txBuffer;
 212   3            ++txBuffer;
 213   3            --txRemaining;
 214   3          }
 215   2          else
 216   2          {
 217   3            UART1_transmitCompleteCb();
 218   3          }
 219   2        }
 220   1      }
 221          
 222          void UART1_writeBuffer(SI_VARIABLE_SEGMENT_POINTER(buffer, uint8_t, EFM8PDL_UART1_RX_BUFTYPE),
 223                                 uint8_t length)
 224          {
 225   1        // Initialize internal data
 226   1        txBuffer = buffer + 1;
 227   1        txRemaining = length - 1;
 228   1      
 229   1        //Send initial byte
 230   1        SBUF1 = *buffer;
 231   1      }
 232          
 233          void UART1_readBuffer(SI_VARIABLE_SEGMENT_POINTER(buffer, uint8_t, EFM8PDL_UART1_TX_BUFTYPE),
C51 COMPILER V9.53.0.0   UART_1                                                            12/29/2017 16:10:08 PAGE 5   

 234                                uint8_t length)
 235          {
 236   1        // Initialize internal data
 237   1        rxBuffer = buffer;
 238   1        rxRemaining = length;
 239   1      }
 240          
 241          void UART1_abortTx(void)
 242          {
 243   1        txRemaining = 0;
 244   1      }
 245          
 246          void UART1_abortRx(void)
 247          {
 248   1        rxRemaining = 0;
 249   1      }
 250          
 251          uint8_t UART1_txBytesRemaining(void)
 252          {
 253   1        return txRemaining;
 254   1      }
 255          
 256          uint8_t UART1_rxBytesRemaining(void)
 257          {
 258   1        return rxRemaining;
 259   1      }
 260          
 261          #endif //EFM8PDL_UART1_USE_BUFFER
 262          
 263          //=========================================================
 264          // STDIO API
 265          //=========================================================
 266          #if EFM8PDL_UART1_USE_STDIO == 1
              char putchar(char c){
                while(!(SCON1 & SCON1_TI__SET));
                SBUF1 = c;
                SCON1 &= ~SCON1_TI__SET;
                return c;
              }
              
              char _getkey(void){
                while(!(SCON1 & SCON1_RI__SET));
                SCON1 &= ~SCON1_RI__SET;
                return SBUF1;
              }
              
              void UART1_initStdio(uint32_t sysclk, uint32_t baudrate)
              {
                SCON1  |= SCON1_REN__RECEIVE_ENABLED | SCON1_TI__SET;
                SMOD1  |= SMOD1_SDL__8_BITS;
                UART1_initBaudRate(sysclk, baudrate);
              }
              
              #endif //EFM8PDL_UART0_USE_STDIO


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    597    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      6    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8      25
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   UART_1                                                            12/29/2017 16:10:08 PAGE 6   

   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
