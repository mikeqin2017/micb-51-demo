C51 COMPILER V9.53.0.0   UART_0                                                            01/08/2018 14:24:09 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE UART_0
OBJECT MODULE PLACED IN .\lib\efm8ub2\peripheralDrivers\src\uart_0.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\SiliconLabs\S
                    -implicityStudio\v4\developer\sdks\8051\v4.1.1\Device\EFM8UB2\peripheral_driver\src\uart_0.c OMF2 SMALL DEBUG OBJECTEXTEN
                    -D ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\User
                    -s\shuwen.ou\SimplicityStudio\v4_workspace\MICB-51\inc;C:\Users\shuwen.ou\SimplicityStudio\v4_workspace\MICB-51\inc\confi
                    -g;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//kits/common/bsp;C:/SiliconLabs/SimplicityStudio/v4/deve
                    -loper/sdks/8051/v4.1.1//kits/EFM8UB2_SLSTK2001A/config;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//De
                    -vice/EFM8UB2/peripheral_driver/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/shared/si8051ba
                    -se;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8UB2/inc;C:/SiliconLabs/SimplicityStudio/v4/
                    -developer/sdks/8051/v4.1.1//kits/common/drivers/efm8_retargetserial) PRINT(.\lib\efm8ub2\peripheralDrivers\src\uart_0.ls
                    -t) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\lib\efm8ub2\peripheralDrivers\src\uart_0.OBJ)

line level    source

   1          /**************************************************************************//**
   2           * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3           *
   4           * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5           *****************************************************************************/
   6          
   7          #include "uart_0.h"
   8          
   9          uint8_t UART0_getIntFlags()
  10          {
  11   1        return SCON0 & (UART0_TX_IF | UART0_RX_IF);
  12   1      }
  13          
  14          void UART0_clearIntFlags(uint8_t flag)
  15          {
  16   1              SCON0 &= ~(flag);
  17   1      }
  18          
  19          void UART0_initTxPolling()
  20          {
  21   1        SCON0_TI = 1;
  22   1      }
  23          
  24          void UART0_write(uint8_t value)
  25          {
  26   1              SBUF0 = value;
  27   1      }
  28          
  29          uint8_t UART0_read(void)
  30          {
  31   1        return SBUF0;
  32   1      }
  33          void UART0_writeWithExtraBit(uint16_t value)
  34          {
  35   1              SCON0_TB8 = value >> 8;
  36   1              SBUF0 = value;
  37   1      }
  38          
  39          uint16_t UART0_readWithExtraBit(void)
  40          {
  41   1        return (SBUF0 | ((SCON0 & SCON0_RB8__BMASK) << 6) );
  42   1      }
  43          
  44          void UART0_init(UART0_RxEnable_t rxen, UART0_Width_t width, UART0_Multiproc_t mce)
  45          {
  46   1          SCON0 &= ~(SCON0_SMODE__BMASK
  47   1                     | SCON0_MCE__BMASK
C51 COMPILER V9.53.0.0   UART_0                                                            01/08/2018 14:24:09 PAGE 2   

  48   1                     | SCON0_REN__BMASK);
  49   1          SCON0 = mce | rxen | width;
  50   1      }
  51          
  52          void UART0_reset()
  53          {
  54   1              SCON0 = SCON0_SMODE__8_BIT
  55   1                              | SCON0_MCE__MULTI_DISABLED
  56   1                              | SCON0_REN__RECEIVE_DISABLED
  57   1                              | SCON0_TB8__CLEARED_TO_0
  58   1                              | SCON0_RB8__CLEARED_TO_0
  59   1                              | SCON0_TI__NOT_SET
  60   1                              | SCON0_RI__NOT_SET;
  61   1      }
  62          
  63          //=========================================================
  64          // Interrupt API
  65          //=========================================================
  66          #if EFM8PDL_UART0_USE_BUFFER == 1
  67          
  68          /**
  69           * Internal variable fort trackig buffer transfers. transferLenth[UART0_TX_TRANSFER] = bytes remaining in 
             -transfer.
  70           */
  71          SI_SEGMENT_VARIABLE(txRemaining, static uint8_t,  SI_SEG_XDATA)=0;
  72          SI_SEGMENT_VARIABLE(rxRemaining, static uint8_t,  SI_SEG_XDATA)=0;
  73          SI_SEGMENT_VARIABLE_SEGMENT_POINTER(txBuffer,    static uint8_t, EFM8PDL_UART0_TX_BUFTYPE, SI_SEG_XDATA);
  74          SI_SEGMENT_VARIABLE_SEGMENT_POINTER(rxBuffer,    static uint8_t, EFM8PDL_UART0_RX_BUFTYPE, SI_SEG_XDATA);
  75          
  76          uint8_t Uart0_Buffer[5];
  77          
  78          SI_INTERRUPT(UART0_ISR, UART0_IRQn)
  79          {
  80   1        //Buffer and clear flags immediately so we don't miss an interrupt while processing
  81   1              static uint8_t i;
  82   1        uint8_t flags = SCON0 & (SCON0_RI__BMASK | SCON0_TI__BMASK);
  83   1              SCON0 &= ~flags;
  84   1      
  85   1        if (rxRemaining && (flags &  SCON0_RI__SET))
  86   1        {
  87   2                      *rxBuffer = SBUF0;
  88   2                      Uart0_Buffer[i]=*rxBuffer;
  89   2                  if(++i==5)i=0;
  90   2                      ++rxBuffer;
  91   2                      --rxRemaining;
  92   2                      if (!rxRemaining)
  93   2                      {
  94   3                              UART0_receiveCompleteCb();
  95   3                      }
  96   2        }
  97   1      
  98   1        if ((flags & SCON0_TI__SET))
  99   1        {
 100   2              if (txRemaining){
 101   3            SBUF0 = *txBuffer;
 102   3            ++txBuffer;
 103   3            --txRemaining;
 104   3          }
 105   2          else
 106   2          {
 107   3            UART0_transmitCompleteCb();
 108   3          }
 109   2        }
C51 COMPILER V9.53.0.0   UART_0                                                            01/08/2018 14:24:09 PAGE 3   

 110   1      }
 111          
 112          void UART0_writeBuffer(SI_VARIABLE_SEGMENT_POINTER(buffer,
 114                                                          uint8_t,
 114                                                          EFM8PDL_UART0_TX_BUFTYPE),
 115                                 uint8_t length)
 116          {
 117   1        //Init internal data
 118   1        txBuffer = buffer+1;
 119   1        txRemaining = length-1;
 120   1      
 121   1        //Send initial byte
 122   1        SBUF0 = *buffer;
 123   1      }
 124          
 125          void UART0_readBuffer(SI_VARIABLE_SEGMENT_POINTER(buffer,
 127                                                                 uint8_t,
 127                                                                 EFM8PDL_UART0_RX_BUFTYPE),
 128                                        uint8_t length)
 129          {
 130   1        //Init internal data
 131   1        rxBuffer = buffer;
 132   1        rxRemaining = length;
 133   1      }
 134          
 135          void UART0_abortWrite()
 136          {
 137   1        txRemaining = 0;
 138   1      }
 139          
 140          void UART0_abortRead()
 141          {
 142   1        rxRemaining = 0;
 143   1      }
 144          
 145          uint8_t UART0_txBytesRemaining()
 146          {
 147   1        return txRemaining;
 148   1      }
 149          
 150          uint8_t UART0_rxBytesRemaining()
 151          {
 152   1        return rxRemaining;
 153   1      }
 154          
 155          #endif //EFM8PDL_UART0_USE_BUFFER
 156          
 157          #if EFM8PDL_UART0_USE_STDIO == 1
              
              #if defined __C51__
              
              char putchar(char c){
                while(!SCON0_TI);
                SBUF0 = c;
                SCON0_TI = 0;
                return c;
              }
              
              char _getkey(){
                while(!SCON0_RI);
                SCON0_RI = 0;
                return SBUF0;
              }
C51 COMPILER V9.53.0.0   UART_0                                                            01/08/2018 14:24:09 PAGE 4   

              
              #elif defined __ICC8051__
              
              int putchar(int c){
                while(!SCON0_TI);
                SBUF0 = c;
                SCON0_TI = 0;
                return c;
              }
              
              int getchar(void){
                while(!SCON0_RI);
                SCON0_RI = 0;
                return SBUF0;
              }
              
              #endif
              
              void UART0_initStdio()
              {
                SCON0 |= SCON0_REN__RECEIVE_ENABLED | SCON0_TI__SET;
              }
              #endif //EFM8PDL_UART0_USE_STDIO
 196          
 197          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    324    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      6    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
